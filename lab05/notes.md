i. Что происходит при прерывании скрипта text-trap.sh?
В обычном режиме (без прерывания) скрипт последовательно выводит числа от 1 до 100. При прерывании Ctrl+C скрипт получает сигнал SIGINT и завершает работу, выведя сообщение "Аварийное завершение..."

ii. Напишите, по какой причине выводы команды `ls -l /proc/self` и `ls -l /proc/$$` разные?
У каталогов разное содержимое: `/proc/self` - подкаталог текущего процесса, `/proc/$$` содержит информацию об открытых файлах процесса `bash`.

iii. Напишите, какие дескрипторы в выводе команды `ls -l /proc/self/fd` отвечают за stdin, stdout, stderr?
Cтандартный ввод: дескриптор 0 (stdin), стандартный вывод: дескриптор 1 (stdout), стандартный вывод ошибок: дескриптор 2 (stderr).

iv. Что происходит с дескрипторами в выводе команды `ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err`?
Перенаправление потока вывода stdout в файл `tmp/ls.out` и потока вывода ошибок stderr в файл `/tmp/ls.err`.

vi. Какой эффект наблюдается при выполнении команды `exec ps -l`?
Создание процесса с кодом `ps -l`. Сначала процесс `/bin/bash` клонирует себя системным вызовом fork(), создавая новый процесс. Клон выполняет системный вызов exec() с указанием на исполняемый файл и заменяет свой код - кодом исполняемого файла (родительский процесс при этом ждет завершения потомка - wait).

vii. Что означает `pos` при выводе содержимого `/proc/$$/fdinfo/3`?
Позиция курсора.

viii. Существует ли возможность читать содержимое файла `test.out` даже после его удаления? Почему так происходит?
На предыдущем шаге мы связали чтение `~/test.out` с дескриптором 4, поэтому даже при удалении файла `~/test.out` значение дескриптора останется в памяти.
